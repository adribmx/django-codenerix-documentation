.. _class-genlist:

GenList
=======

.. code:: python

    from codenerix.views import GenList


    class NameModelList(GenList):
        model = NameModel
        show_details = True


Description
+++++++++++

Generates automatically the templates and basic methods like get or post to produce a model list. We recomended that the name of each class which inherit from GenList follow this pattern: NameModel+List.

Genlist support Memcache.

- Example:
    If model is User, then, GenList declarations should be, ``class UserList(GenList):`` 

Attribute
+++++++++

===========
annotations
===========

Create new fields to search and return the result of a function.

.. code:: python

    annotations = {
        'min_price': Min('books__price'),
        'max_price': Max('books__price')
    }


==============
client_context
==============

Contains information about the filters in the client side. This structure will be returned inside the meta structure from JSON answers.

================
default_ordering
================

Indicates the order of the list showed by the view. Ordering can be incremental or decremental.

.. code:: python

    default_ordering = '-field'  # Decremental
    default_ordering = 'field'   # Incremental

=============
extra_context
=============

Contains information to add extra parameters in a template context. This structure will be returned inside the meta structure from JSON answers.

==============
json ``basic``
==============

If True the view returns the information in json format, else render a template (Default value is False).

=================
linkadd ``basic``
=================

If False codenerix won't render the add button in the template (Default value is True).

==================
linkedit ``basic``
==================

If False codenerix won't move to the edit view when a row is activated (Default value is True).

=============================
model ``basic`` ``mandatory``
=============================

Model on which the searches will be carried out. Value must be a class which inherits :ref:`class-codenerixmodel`. All ListView must have model asociated.

=================
must_be_superuser
=================

Is True only superusers can see the template generated by this view (Default value is False). 

==========
permission
==========

Specify necessary permissions to access this view. Value of this attribute can be a single string or a string list.

.. code:: python

    # With string
    permission = 'permission1'

    # With a string lis
    permission = ['permission1', 'permission2', ...] 

================
permission_group
================

Specify necessary permissions groups to access this view. Value of this attribute can be a single string or a string list

.. code:: python

    # With string
    permission_group = 'group1'

    # With a string list
    permission_group = ['group1', 'group2', ...]

======================
show_details ``basic``
======================

If True render the detail view instead the edit view when a row is activated (Default value is False).

==================
static_filters_row
==================

.. TODO:: Document this

==================
static_partial_row
==================

You can customize how show each row of table and format all data showed.


.. code:: python
    
    static_partial_row = 'templatedir/nametemplate.html'


.. code:: html

    <!-- This example show 3 field, a button for edit and a fuction angular for 
    manage 2 conditional images.  -->
    <td>{{row.name_field1}}</td>
    <td>{{row.name_field2}}</td>
    <td>{{row.field3}}</td>
    <td ng-click="edit(row.pk)">{{row.field4}}</td>
    <td ng-click="angularFunction(row.pk, row.datacheck)" id="row.pk">
      <i ng-show="isvalid(row.check)" class="fa fa-times text-danger"></i>
      <i ng-hide="isvalid(row.check)" class="fa fa-check text-success"></i>
    </td>

=============
template_base
=============

If specified, Codenerix will load it as the base template (Default value is "base/base.html"). If the specified template doesn't exist, this view won't work.

=================
template_base_ext
=================

Indicate the extension of the base template (usually is html)

==============
template_model
==============

If specified, Codenerix will load this template. If doesn't exist, Codenerix will try to figure out automatically which template to use. If the specified template doesn't exist, this view won't work.

==================
template_model_ext
==================

Indicate the extension of the template (usually is html)

======
vtable
======

If True Codenerix will render the template in one-page-only with a scroll, else the table will have pagination (Default value is False).

========================
ws_entry_point ``basic``
========================

Codenerix use two steps to show a data table. The first step is render the template with basic structure and the second one is using AngularJs to make a request to the backend and receive all raw data. ws_entry_point indicates which url use to make the request (Default value will be the url with next structure).

.. code:: python

    model = nameModel 
    ws_entry_point = nameModel.lowerCase() + 's/list'

Methods
+++++++

======================
__fields__(self, info)
======================

This is a method to tell Codenerix which of the model fields must be showed. If this method is declared in a :ref:`class-genlist` will prevail over the one implemented in the associated model.


.. code:: python

    def __fields__(self,info):
        fields = []
        fields.append(('nameField1', _('labelField1', 100, 'left'))
        fields.append(('nameField2', _('labelField2'), None, 'center'))
        fields.append(('nameField3', _('labelField3')))
        return fields



Parameters
----------
- info: Contains all the basic information from the session.

Return
------

- List of parameters list. Each list represents a model field and associated parameters:

    - Identifier: Field name, have to be a member of the model. ``cannot be null``
    - Label : Field label. ``cannot be null``
    - Size : Size in pixels of the form widget.
    - Alignment: Alignment of the columns name. Options are (left | center | right).

======================
__limitQ__(self, info)
======================

Filters data for a static value (For example, if you want that a certain role only see its own clients, limitQ can filter the resulting queryset by the clients of the logged user). If this method is declared in a :ref:`class-genlist` will prevail over the one implemented in the associated model.

.. code:: python

    def __limitQ__(self, info):
        criteria = []
        criteria.append(Q(model__pk=pk_condition))
        criteria.append(Q(model__field1=condition))
        limits = {}
        limits['profile_people_limit'] = reduce(operator.or_, criterials)
        return limits

Parameters
----------
- info: Contains all basic information from the session.

Return
------

Returns a dictionary with a set of Q conditions.


=======================
__searchQ__(self, info)
=======================

Manages a text filter. If this method is declared in a :ref:`class-genlist` will prevail over the one implemented in the associated model.

.. code:: python

    def __searchQ__(self, info, text):
        text_filters = {}
        text_filters['identifier1'] = Q(CharField1__icontains=text)
        text_filters['identifier2'] = Q(TextField1__icontains=text)
        text_filters['identifier3'] = Q(IntegerField=34)

        # If text have this a especific word can return another Q condition. 
        if text.find(u'magic') != -1:
            text_filters['identifier4'] = Q(identifier=34)

        return text_filters


Parameters
----------
- info: Contains all basic information from the session.
- text: Text used to filter.

Return
------

Returns a dictionary with all Q conditions.

=======================
__searchF__(self, info)
=======================

Declare predefined search filters. If this method is declared in a :ref:`class-genlist` will prevail over the one implemented in the associated model.

.. code:: python

    def __searchF__(self, info):
        list1 = []
        for l1 in Model.objects.all():
            list1.append((l1.id, l1.field1 + ' ' + l1.field2))

        list2 = [] 
        for li in Model2.objects.all():
            list2.append((li.id, str(li.field)))

        text_filters = {}
        text_filters['field1'] = (_('Field1'), lambda x: Q(field1__startswith=x), [('h', _('Starts with h')), ('S', _('Starts with S'))])
        text_filters['field2'] = (_('Field2'), lambda x: Q(field2__pk=x), list1)
        text_filters['external'] = (_('Field3'), lambda x: Q(pk=x),list2)
        return text_filters


Parameters
----------
-  info: Contains all basic information from the session.

Return
------

Returns a dictionary of tuples. Each tuple have three fields with following structure:

-  Name: Name of the selector. If match a model field name, the filter will positionate in the column, else the choicebox will put on default site.
-  Function: Is a lambda function to specify search methods. 
-  Choices: A tuple with two fields (value, label).


More examples
+++++++++++++

==========
Basic List
==========

.. code:: python

    class NameModelList(GenList):
        model = ModelName

==============
With filtering
==============

.. code:: python

    class NameModelList(GenList):
        model = ModelName

        def __fields__(self, info):
            fields = []
            fields.append(('field1', _('label1'), 100))
            fields.append(('field2', _('label2'), 100))
            fields.append(('field3', _('label3'), 100))
            return fields

        def __limitQ__(self, info):
            criterials = []
            criterials.append(Q(model__pk=pk_condition))
            criterials.append(Q(model__field1=condition))
            limits = {}
            limits['profile_people_limit'] = reduce(operator.or_, criterials)
            return limits

        def __searchQ__(self, info, text):
            text_filters = {}
            text_filters['field1'] = Q(field1__icontains=text)
            text_filters['field2'] = Q(field2__icontains=text)

            return text_filters

        def __searchF__(self, info):
            list1 = []
            for l1 in Model.objects.all():
                list1.append((l1.id, l1.field1 + ' ' + l1.field2))

            list2=[]
            for li in Model2.objects.all():
                list2.append((li.id, str(li.field)))

            text_filters = {}
            text_filters['field1'] = (_('Field1'), lambda x: Q(field1__startswith=x), [('h', _('Starts with h')), ('S', _('Starts with S'))])
            text_filters['field2'] = (_('Field2'), lambda x: Q(field2__pk=x), list1)
            text_filters['external'] = (_('Field3'), lambda x: Q(pk=x), list2)
            return text_filters

==================
How create sublist
==================

.. code:: python

    # A sublist is a list, but its url is called from a detail view and rendered automatically
    class NameModelSubList(GenList):
        model = ModelName

        def __limitQ__(self, info):
            limits = {}
            pk = info.kwargs.get('pk',None)
            limits['file_link'] = Q(foreigntofathermodel__pk=pk)
            return limits
